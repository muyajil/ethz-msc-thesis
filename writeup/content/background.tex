\chapter{Background}

\section{Recommendation Systems}
\subsection{Problem Statement}
Generally speaking recommendation systems are concerned with recommending items to be of use to users.
The recommendations should help the users decide which items to buy, music to listen to, what news articles to read etc.
Virtually any decision-process can be made easier for users by providing recommendations.
Typically recommendation systems are used by online services, famously for example by Spotify for music~\cite{rec_spotify} and YouTube for videos~\cite{rec_yt}.
By using these online service the users generate data that the service can use to improve the recommendations, for example rating videos gives the operator of the service a datapoint on how much a video is liked by a specific user.
However also retailers are known to use recommendation systems, based on data generated by customer loyalty programs such as Migros Cumulus~\cite{rec_migros} retailers tailor coupons or other offers to their customers.
In principle data of users interacting with items (viewing, buying, rating etc.) serves as the basis for a recommendation system. 
Depending on the use-case this data is utilized to assign scores to items depending on the user. 
The semantic meaning of a score depends on the objective of a recommendation system.
For example a system which recommends products to be bought might assign a "probability of purchase", whereas a system which recommends videos might predict the probability of a user watching a video to the end. 
\\
Bringing this all together we can define a general recommendation system with the following function:
\[
    s = f(i, u, h_u)
\]
Where $s$ is the assigned score to item $i$ for the user $u$ and the users history $u_h$. 
The users history represents all the previous interactions with items.
Essentially when we design a recommendation engine we want to learn the function $f$.
To assess the quality of the learned function we need to know the "true" score for the specific item and user, this can be done in different ways.
Usually during training we will hold off later interactions with items, and test the learned functions on those.
However as soon as the users sees recommendations, we essentially change the reality, i.e. we don't know what the user saw as recommendations, if any, in the user history, therefore it makes sense to also assess the performance of a recommendation engine in production.
\subsection{Properties of Recommendation Systems}
In the following we will look at different properties of recommendation systems.
Typically recommendation systems have a combination of the following properties.
\paragraph{User-based}
User-based recommendation system base the information used to make recommendations mainly on properties of the user, such as gender, age, etc.
Also information from the history of the user can be used, for example what the user has bought or read before.
Essentially that means when we try to generate recommendations for a specific user we try to find similar users and recommend items that the similar users liked. 
\paragraph{Item-based}
Item-based recommendation system use mostly information about the item to produce recommendations, such as item type (e.g. genre of a movie).
However as the name suggests, the basis for a recommendation is always a specific item, for example a product a user is looking at online.
This item the user is currently interacting with is referred to as the "active item". 
Usually item-based recommendation systems then try to find similar items to the currently active item. 
The method of finding similar items can be arbitrarily complex, identifying similar items is its own field of research.
What is also often done is combine this approach with a user-based component, where the similar items are sorted or filtered based on the user.
An example of this might be the following:
\begin{itemize}
    \item Steve is a male looking at black shirts.
    \item When extracting similar products we find a range of black shirts, also containing womens shirts.
    \item If we would recommend items by popularity the womens shirts would appear as the first recommendation, since women typically buy more shirts.
    \item Instead of directly displaying the recommendations we filter out the womens shirts that is found in this selection.
\end{itemize}
\paragraph{Session-based}
Session-based recommendation systems are a rather new form of such a system.
A session is a sequence of interactions from a user with one or several items.
Depending on the use-case and setting this can be defined differently.
Usually online-services define a session as the sequence of interactions a user produces on the site until closing the browser window.
Obviously sessions can have variable lengths, therefore it is difficult to directly feed that information into a recommendation system.
However with the rise of Recurrent Neural Networks (c.f.~\ref{rnn}) a powerful tool for handling variable length sequence data becomes available.
Session-based recommendation systems use RNNs to model the sequence data generated by sessions to achieve two things.
First by using RNNs we can extract a fixed dimensional representation of a specific session, this allows us to compare different sessions.
Second by using the fixed representation of a session we can try to identify the intent a user has in a specific session, based on this recommendations can be made to fulfill the users intent.
An intent can be defined as the goal the user has in a specific session.
In the example of an online-shop there are a few different, well-known intents identified by analysts such as: Browsing for inspiration, searching for a specific product, buying a specific product, researching products etc.
Also these intents exist in different contexts, in the case of an online-shop the contexts can be different product types (mobile phone, couch, dining table) etc.
From the above explanation it is intuitive to see why these systems are more desired by operators of online services, since the recommendations can be targeted much more specific to the user and his intent, instead of just general information of the user and the active item. 
\paragraph{Collaborative}
Collaborative recommendation-systems mostly use interaction data to generate recommendations.
For example we use the clicks on products as a data source and then predict which products the user will click next.
However the collaborative aspect comes from the fact that we source other users interactions as a basis for the recommendations.
In principle we view different users as versions of possible behaviour of a user, the more interactions two users have in common, the more similar they are assumed to be.
Therefore we can extend the behaviour (i.e. product views) of a user by looking at what similar users have done on the same active item.
\paragraph{Content-based}
In contrast to collaborative recommendation systems, content-based systems heavily rely on so called content information.
Content information refers to the actual content of different items.
The name stems from early recommendation systems which mainly focussed on recommending media.
The idea is to actually analyze the content of an item, be it the images in a movie, the soundwaves of a song or the text in a book.
The assumption is that a user likes to see items that are similar to each other (e.g. a user who mostly likes action films).
However this method can also be used in different contexts, such as online-shopping, where the "content" of an item might be its textual description or an image of the actual product.
\subsection{Well-Known Examples}
\begin{itemize}
    \item Describe a classical user based approach
    \item Describe a classical item based approach
\end{itemize}

\section{Concepts}
\subsection{Recurrent Neural Networks}\label{rnn}
\begin{itemize}
    \item Explain the concept of neural Networks
    \item What are the problems (vanishing gradients etc)
    \item Explain what a GRU is and why does it handle vanishing gradient better than simple RNN cells?
    \item How does a layered RNN work?
\end{itemize}
\subsection{Generative Adversarial Network Framework}
\begin{itemize}
    \item Explain the way GANs work
    \item Loss function is learnable
    \item The discriminator is part of the loss function
    \item Especially good if we want generate stuff
\end{itemize}
\subsection{Teacher Forcing}
\begin{itemize}
    \item RNN have two modes: Teacher forced and Free running
    \item When training we always use the ground truth as input
    \item This generates two different distributions of hidden states, which in turn generates two different distributions for the output
    \item This is a problem since this makes RNNs in production less predictable
\end{itemize}

\section{Previous Work}
\subsection{Professor Forcing}
\begin{itemize}
    \item Here we want to mitigate the teacher forcing problem, by applying the gan framework
    \item Add graphic showing how it should work
    \item Describe the model as we did in the slides, show the loss function
\end{itemize}
\cite{profforce}
\subsection{Meta-Prod2Vec}
\begin{itemize}
    \item This is a model that allows us to capture the semantic similarity between products
    \item Explain how it works by relating to word2vec (refer to word2vec paper)
\end{itemize}
\cite{prod2vec}
\subsection{Hierarchical RNNs for personalized Recommendations}
\begin{itemize}
    \item This is the starting point for the thesis
    \item Which components does the system have?
    \item Show the graphic from the paper
\end{itemize}
\cite{hierarchical}

\section{KPIs}
\subsection{Click-Through-Rate}
\subsection{Conversion Rate}
\begin{itemize}
\item Describe different KPIs
\item What do they meaure, how to optimize for it
\end{itemize}